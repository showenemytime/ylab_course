# cписок мест
places = [["Почтовое отделение", (0, 2)], ["Ул. Грибоедова, 104/25", (2, 5)], ["Ул. Бейкер стрит, 221б", (5, 2)],
        ["Ул. Большая Садовая, 302-бис", (6, 6)], ["Вечнозелёная Аллея, 742", (8, 3)]]
min_dist = 100  # переменная для поиска мин дистанции от точки А до каждой другой
avoid_index = [0]  # список индексов точек, в которых уже был почтальон, чтобы не ходил туда 2 раз
total_distance = 0  # переменная для подсчёта дистанции, которую пройдёт почтальон
distance_list = [0]  # список, чтобы потом вывести расстояниее от точки А до Б

#  ((point_2[0] - point_1[0]) ** 2 + (point_2[1] - point_1[1]) ** 2) ** 0.5
#  Цикл, в котором мы идём от Почтового отделения до каждой точки и фиксируем наимменьшее расстояние. Допустим это будет
#  точка Ул. Грибоедова. Тогда высчитываем записываем эту дистанцию в Тотал Дистанс и добавляем индекс этой точки в
#  avoid_index, чтобы не ходить второй раз. Затем повторяем, от Ул. Грибоедова ищем ближайшую точку, но не
#  Почтовое отделение, так как этот индекс тоже в avoid_index.
while True:
    el_index = None
    for i in range(1, len(places)):
        # проверяем, что в этой точке мы ещё не были, если это так- то заходим на рассчёт растояния между точками
        if i not in avoid_index:
            # берём точку, в которой мы сейчас находимся и измеряем расстояние до каждой точки, в которой мы ещё не были
            distance = ((places[i][1][0] - places[avoid_index[-1]][1][0]) ** 2 + (places[i][1][1] - places[avoid_index[-1]][1][1]) ** 2) ** 0.5
            # минимальное расстояние записываем в min_dist, а индекс этой точки в el_index, чтобы потом добавить его в avoid_index
            if distance < min_dist:
                min_dist = distance
                el_index = i
    avoid_index.append(el_index)  # добавляем точку с минимальным расстоянием в avoid_index, чтобы не ходить в неё 2 раз
    total_distance += min_dist  # прибавляем расстояние к общему
    distance_list.append(total_distance)  # добавляем расстояние между точками для вывода в конце
    # ((places[el_index][1][0] - places[avoid_index[-1]][1][0]) ** 2 + (places[el_index][1][1] - places[avoid_index[-1]][1][1]) ** 2) ** 0.5
    min_dist = 99  # возвращаем минимальную дистанцию к заведома большей чем между любой из точек

    # Если в avoid_index уже 5 точек, значит всё точки пройдены и можно завершать цикл.
    if len(avoid_index) == len(places):
        break

# возвращаем почтальона в Почтовое отделение, прибавляем к обещей дистанции дорогу от финальной точки к Почте.
total_distance += ((places[avoid_index[-1]][1][0] - places[avoid_index[0]][1][0]) ** 2 + (places[avoid_index[-1]][1][1] - places[avoid_index[0]][1][1]) ** 2) ** 0.5

#  в avoid_index мы добавляли индексы по очереди движения почтальона. По нему выводим его путь.
temp = 0  # темп временно нужен, так как distance_list хранит записи в другом порядке, чем avoid_index
for i in avoid_index:

    print(f'{places[i][1]} {distance_list[temp]} -> ', end=' ')

    temp += 1
print(f'{places[0][1]} {total_distance}')
